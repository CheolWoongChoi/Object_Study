
## 13장. 서브클래싱과 서브타이핑

### 특징
- 상속은 2가지 목적으로 사용한다.
- 1) 타입계층 구현 2) 코드 재사용
- 객체의 행동을 기반으로 타입 계층을 구성


### 01) 타입
- 개념 관점 : "공통의 특징"으로 분류
- 프로그래밍 관점 : 적용 가능한 "오퍼레이션의 종류와 의미(또는 '집합')"를 정의
- 객체지향 관점 : 객체가 수신할 수 있는 메시지의 종류(또는 '집합')
  - 객체지향 프로그래밍에서의 타입 정의 == 퍼블릭 인터페이스 정의
  - 동일한 타입 == 동일한 퍼블릭 인터페이스


### 02) 타입 계층
- 일반화 : 다른 타입을 포함, 내포하는 타입을 식별
- 특수화 : 다른 타입 안에 전체적으로 포함, 완전히 내포되는 타입
- 일반적인 타입 : 슈퍼 타입 (super type)
- 더 특수한 타입 : 서브 타입 (sub type)


### 03) 서브클래싱 & 서브타이핑

- 상속은 언제?
  - is-a 관계
  - 클라이언트 입장에서 클래스 간 차이점을 몰라도 될 때 (행동 호환성)

- 인터페이스 분리 원칙 (ISR) : 인터페이스를 "클라이언트의 기대"에 따라 분리함으로써, 변경에 의해 영향을 제어하는 설계 원칙

- 1) 서브 클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속
  - "구현 상속" 또는 "클래스 상속" 이라고도 함

- 2) 서브 타이핑 : 타입 계층을 구성하기 위해 상속
  - "인터페이스 상속"
  - 객체의 "행동 호환성", "대체 가능성"을 가능케함


### 04) 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

- 요약 : 서브타입은 그것의 기반타입에 대해 대체 가능해야 한다.
- ** 행동호환성을 설계원칙으로 정리한 것


### 05) 계약에 의한 설계와 서브타이핑 (좀 어렵다..)

- 계약에 의한 설계(DBC)
  - 클라이언트와 서버 간 "의무"와 "이익"이 존재
  - 다음 3가지가 만족해야 함
  - 사전조건 : 클라이언트가 정상적으로 메서드를 실행할 조건
  - 사후조건 : 메서드 실행 후, 서버가 클라이언트에게 보장할 조건
  - 클래스 불변식 만족

- "계약에 의한 설계"를 사용하면 LSP(리스코프 치환 원칙)가 강제하는 조건을 계약의 개념으로 명확하게 설명 가능

- 사전조건 특징 : 서브타입이 슈퍼타입과 같거나 약해야 한다. (조건)
- 사후조건 특징 : 서브타입이 슈퍼타입과 같거나 강해야 한다. (조건)


## 14장. 일관성 있는 협력

### 요약
- 일관성있는 유사한 협력 패턴 -> 재사용 UP + 시간 DOWN + 비용 DOWN
- 유사한 기능구현 -> 유사한 방식으로 구현해야 좋다.

### 01) 핸드폰 과금 시스템 변경하기
- 일관성 없는 설계 + 무의미한 상속 -> HELL CODE

### 02) 설계에 일관성 부여하기
- 다양한 설계 경험 익히기 (*** 본인도 공부 많이하고, 경험을 많이 쌓아야)
- 디자인 패턴 학습 & 적용해보기

- 지침1) 변하는 개념과 변하지 않는 개념 분리
- 지침2) 변하는 개념을 캡슐화

- 예시)
- 조건문 (개별적인 변경)
  - "개별적인 객체"로 변경
  - 객체들과 일관성 있도록 타입계층 구현
  - 변하는 개념을 서브타입으로 분리 & 캡슐화

- 캡슐화란 변하는 어떤 것이든 감추는 것이다.
  - 개별객체에 대한 변경관리 : "데이터 캡슐화", "메서드 캡슐화"

- 협력에 참여하는 객체들의 관계에 대한 변경관리 : "객체 캡슐화"(합성), "서브타입 캡슐화"(인터페이스 상속)

### 03) 일관성 있는 기본 정책 구현하기
- 변경 캡슐화
- 협력 패턴 설계하기
- 개념적 무결성(Conceptual Integrity) : 유사한 기능에 대해 유사한 협력패턴을 적용하는 것


## 기타 모임에서 한 이야기
- 프론트 개발은 정말 빠르게 변한다...
- 테스트 / CI,CD / 에러체킹 / unit Test / e2e Test 등...
- 아키텍처를 잘 설계할 줄 알아야 한다.
- 아무튼 열심히 공부하자! ㅎㅎ

