
## 5장. 책임 할당하기

- 클래스 기반 설계 -> 메시지 기반 설계
- [A 객체]  --- (메시지, 책임, 캡슐화) --> [B 객체]

- 책임할당 패턴 
  - GRASP 패턴 (General Responsibility Assignment Software Pattern, 일반적인 책임할당을 위한 소프트웨어 패턴)

- 패턴 종류
  - Information Expert 패턴 (책임을 수행할 정보를 알고 있는 객체)

  - Low Coupling (낮은 결합도) 패턴
    - 의존성을 낮추고, 변화의 영향을 줄이며, 재사용성을 증가시킬 수 있는 가?

  - High Cohesion (높은 응집도) 패턴
    - 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?
    - 관련된 코드 (책임/기능/데이터)로 이루어져 있는가
    - 단일책임원칙 (S)과도 연관 있는 듯

  - Creator (창조자) 패턴

  - Polymorphism vㅐ턴
    - 객체의 타입을 검사해서 책임할당
    - 조건적인 논리 사용 X (if문, switch 문)

  - Protected Variations (변경보호) 패턴
    - 캡슐화
    - 책임에 맞게 변경 -> 관심사 분리

- 기타
  - 절차형 코드 -> 객체지향 코드로 바꾸기
  - 긴 메서드 (몬스터 메서드: 로직이 너무 복잡해서 가독성/결합도가 높음)를 작은 메서드로 잘게 나눠보기


## 6장. 메시지와 인터페이스

- [A 객체] ----- [B 객체]
  - 클라이언트 - 서버 모델 (웹처럼 객체도 클라이언트-서버 모델 형태를 가질 수 있다.)
  - condition.isSatisfiedBy(screening)
    - condition: 수신자(서버)
    - isSatisfiedBy: 오퍼레이션명
    - screening: 인자
    - 메시지: 오퍼레이션명 + 인자 (isSatisfiedBy, screening)

- 메시지와 메서드 구분하기
  - 추상화 vs 구체화

- 최소한의 인터페이스, 추상적인 인터페이스 추구하기

- 메시지와 인터페이스 제대로 활용하기
  - 1. 디미터 법칙
    - 협력 경로를 제한시켜라
  - 2. 묻지말고 시켜라
    - 다른 객체에게 위임
  - 3. 의도를 드러내는 인터페이스를 만들어라
    - 퍼블릭 인터페이스

- 명령 & 쿼리
  - 명령: 사이드이펙트 O, 리턴 X, 프로시저
  - 쿼리: 사이드이펙트 X, 리턴 O, 함수

  - 부수효과로 대표적인 것
    - 대입문
    - 부수효과를 일으키는 함수







