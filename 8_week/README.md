
## 15장. 디자인패턴과 프레임워크


### 00) 도입부
- 디자인패턴 : 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법
  - 설계를 재사용
- 프레임워크 : 설계와 코드를 함께 재사용하기 위한 것

### 01) 디자인패턴과 설계재사용
- 패턴분류
  - 아키텍처 패턴
  - 분석 패턴
  - 디자인 패턴
  - 이디엄

- 분석 패턴
  - 도메인 내의 개념적인 문제 해결 목적
  - 업무 모델링 시, 공통적인 구조를 표현하는 개념집합

- 아키텍처 패턴
  - 소프트웨어의 전체적인 구조 결정
  - 미리 정의된 서브시스템 제공, 서브시스템 책임 정의
  - 서브시스템 간 규칙, 가이드라인 제시
  - 프로그래밍 언어나 프로그래밍 패러다임에 독립적

- 디자인 패턴
  - 중간규모의 패턴
  - 특정한 설계문제 해결 목적
  - 프로그래밍 언어나 프로그래밍 패러다임에 독립적

- 패턴과 책임 주도 설계
  - STRATEGY 패턴 : 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임집합 제공
  - BRIDGE 패턴
  - OBSERVER 패턴
  - COMPOSITE 패턴
  - TEMPLATE 패턴
  - DECORATOR 패턴
  등...

- 요약
  - 패턴의 최종 결과를 이해하는 것보다, 패턴을 목표로 리팩토링하는 이유를 이해해라
  - 훌륭한 소프트웨어 설계발전 과정 > 훌륭한 설계자체


### 02) 프레임워크와 코드 재사용
- 코드 재사용 vs 설계 재사용

- 상위정책과 하위정책으로 패키지 분리하기

- 제어역전 원리

- 마지막. 나아가기
  - 디자인 패턴
  - 리팩터링
  - 테스트 주도 개발
    - 설계 - 구현 - 테스트 (기존)
    - 테스트 - 구현 - 설계 (TDD)
    - 메시지를 먼저 선택하고, 메시지가 객체를 선택하게 한다는 '책임-주도-설계'와 어울림
  



## 부록 A. 계약에 의한 설계 (Design By Contact, DBC)


### 01) 협력과 계약
- 부수효과를 명시적으로

- 계약
  - "계약당사자"는 "이익"을 기대하고 "의무"를 이행
  - "계약당사자"의 이익과 의무는 계약서에 문서화
  - "계약"이라는 아이디어를 객체들이 협력하는 방식에 적용해보자 -> DBC

### 02) 계약에 의한 설계
- 협력에 참여하는 객체는 "계약"으로부터 "이익" 기대, "의무" 이행

- 협력에 참여하는 객체의 "이익"과 "의무"는 인터페이스에 명시
  - 사전조건
  - 사후조건
  
- 불변식
  - 인스턴스 생명주기 전반에 걸쳐 지켜야 하는 규칙 명세
  - 생성자 실행 후, 메서드 실행 전, 메서드 실행 후, 호출

### 03) 계약에 의한 설계와 서브타이핑
- 리스코프 치환을 만족시키는지 체크

- 계약 규칙
  - 서브타입에 더 강력한 사전조건을 정의할 수 없다. (사전조건 완화 ok)
  - 서브타입에 더 완화된 사후조건을 정의할 수 없다. (사후조건 강화 ok)

- 슈퍼타입의 불변식은 서브타입에서도 반드시 유지되어야 한다.
  - "메서드 실행되기 전과 후에 만족해야 하는 조건"
  - 상위 클래스(모듈)에서 private 선언
  - 하위 클래스에선 protected 필요할 때, 불변식 체크

- 가변성 규칙
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.
  
  - 서브타입의 리턴타입은 공변성을 가져야 한다. (DBC의 사후조건 강화와 관련)
    - T가 슈퍼타입, S가 서브타입 이라고 하자.
    - 공변성 : S가 T대신 사용가능
    - 반공변성 : T가 S대신 사용가능
    - 무공변성 : T, S는 아무사이 X, 각자 서로를 대신 X

  - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
    - 파라미터 반공변성 : "부모 클래스"에서 구현된 메서드를 "자식 클래스"에서 오버라이딩할 때, 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성

- 함수 타입과 서브타이핑
  - 이름없는 메서드 : 익명함수 or 함수 리터럴 or 람다표현식
  - 객체의 서브타입이 객체 슈퍼타입을 대체
  - 서브타입 메서드가 슈퍼타입 메서드 대체




## 부록 B. 타입계층의 구현


### 01) 클래스를 이용한 타입계층 구현
- 타입 == 객체의 퍼블릭 인터페이스 == 사용자정의 타입
- 클래스 상속 -> 가급적 추상클래스 or 인터페이스 구현

### 02) 인터페이스를 이용한 타입계층 구현
- 여러 클래스가 동일한 타입 구현
- 하나의 클래스가 여러 타입 구현

### 03) 추상 클래스를 이용한 타입계층 구현
  - 의존하는 대상의 추상화 정도
    - 의존성 역전 원칙의 변형 : 추상메서드에 의존

  - 상속을 사용하는 의도
    - 주로 미래에 사용이 변경될 줄 모르는 경우

### 04) 추상 클래스와 인터페이스 결합하기
  - "인터페이스"로 타입을 정의
  - "추상클래스"로 특정상속 계층, 코드중복 방지

### 05) 덕 타이핑
  - 주로 동적타입 언어에서 사용

  - 정적언어(Java)에서는 객체에 동일한 메서드가 있어도 같은 타입으로 판단 안함

  - 객체지향 설계의 목표
    - 코드 수정 비용 Down
    - 메시지 & 퍼블릭 인터페이스 구축
    - 덕 타이핑은 클래스 or 인터페이스에 대한 의존성을 메시지에 의한 의존성으로 대체

### 06) 믹스인과 타입계층
  - 믹스인(mixin) : 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스
  - 믹스인을 이용해, 간결한 인터페이스를 풍부한 인터페이스로 만들 수 있음




## 부록 C. 동적인 협력, 정적인 코드

### 00) 개요
  - 동적 모델 : 프로그램 실행 구조를 표현하는 움직이는 모델
    - 객체
    - 협력
  - 정적 모델 : 코드의 구조를 담는 고정된 모델
    - 타입
    - 관계

### 01) 동적 모델과 정적 모델
  - 행동이 코드를 결정한다.
  - 변경을 고려해라.

### 02) 도메인 모델과 구현
  - 도메인 모델
    - 도메인 모델 : 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 것.

  - 행동과 변경을 고려한 도메인 모델.

