
## 9장. 유연한 설계

### 1) 개방-폐쇄 원칙
- 개념: 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 열려있어야 하고, 수정에 닫혀 있어야 한다.
  - 확장에 열려 있다. (새로운 동작 추가)
  - 수정에 닫혀 있다. (기존 코드를 수정 X)
  
- 추상화에 의존
  - 다양한 상황에서의 공통점을 반영한 추상화의 결과물
  - 추상화된 부분은 수정에 닫혀 있다. (추상화에 대한 의존)
  - 추상화가 생략된 부분은 확장의 여지
  - 변하는 것 vs 변하지 않는 것: 설계는 충분히 고민해야 한다.


### 2) 생성/사용 분리
- 앞의 8장에서 이야기한 의존성 해결 기법이 구체적으로 소개
- 객체 생성과 객체 사용은 서로 다른 책임이다.
  - 객체 생성: 클라이언트로 책임 이동 (객체 내부가 아닌 객체 외부에서 사용할 객체를 생성)

- Factory
  - 그 유명한 Factory 패턴
  - 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체
  
- 순수한 가공물 (Pure Fabrication)
  - '도메인'과 무관한 인공적인 객체 (도메인이란 '문제해결' 또는 '어떤 목적'을 위해 프로그래밍을 하는 것 또는 그런 시스템)
  - 객체 분해는 표현적 분해 (도메인 개념)와 행위적 분해 (객체지향, 인공적, 추상화)로 분류할 수 있다.
  - 순수하게 창조된 객체(인공적 객체 또는 디자인 패턴)
    - 어떤 문제를 해결한다기 보다는 (비즈니스 로직) 깔끔한 코드를 위해 인위적으로 패턴을 만든 것

### 3) 의존성 주입 (Dependency Injection)
  - 개념: 외부의 독립적인 객체가 인스턴스를 생성한 후, 이를 전달해서 의존성을 해결하는 기법
  - 의존성 해결 기법
    - 생성자 주입
    - Setter 주입
    - 메서드 주업

  - Service Locator 패턴
    - 별도의 객체에 의존성을 의존
    - 이 객체에서 원하는 의존성을 꺼내서 사용


### 4) 의존성 역전 원칙
  - 개념: 상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안된다.
  - 모든 의존성의 방향이 추상클래스나 인터페이스와 같은 추상화를 따라야 한다.

  - 특징
    - 1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
    - 2. 추상화는 구체적인 사항에 의존해선 안된다. 구체적인 사항은 추상화에 의존해야 한다.

  - "역전"의 의미
    - 기존 절차적 프로그래밍과는 다르게 (상위 모듈 -> 하위 모듈로 의존) 
    - 의존성 방향이 반대로 나타남 (하위 모듈 -> 상위 모듈 의존)
    
### 5) 유연성에 대한 조언
  - 유연한 설계 VS 단순, 명확한 설계
    - 유연한 설계: 복잡도가 올라갈 수 있다.
    - 단순, 명확한 설계: 설계는 단순하지만, 의존성이 강하게 결합될 수 있다.

  - 협력과 책임에 따라 '상황'에 맞게 설계를 해야 한다.



## 10장. 상속과 코드 재사용

### 중복된 코드를 제거하려는 의지
  - 상속
  - 합성

### 1) 상속과 중복 코드
- DRY 원칙
  - 중복 코드의 문제점
    - 1. 수정 비용 UP
    - 2. 테스트 비용 UP
    - 3. 정신적 타격 UP
   - 결과적으로 1) 변경 취약 2) 버그 가능성 UP 3) 또 다른 중복 코드의 발생
   - 예시)
    - 한 곳을 수정했는데, 다른 곳은 수정 안됨
    - 한 곳을 수정했는데, 다른 곳은 다르게 동작

- 중복 코드 해결
  - 타입 코드
    - Switch 문 또는 조건문
  - 상속
    - 문제점
      - 결합도 UP
      - 상속을 이용해서 코드를 재사용하기 위해서 부모 클래스의 설계, 로직 이해가 필요

### 2) 취약한 기반 클래스 (상속의 문제)
- 불필요한 인터페이스 상속 문제
- 메서드 오버라이딩의 오작동 문제
- 부모 클래스와 자식 클래스의 동시 수정 문제
  - 부모-자식 구현이 변하지 않거나,
  - 부모-자식 동시에 변경

### 3) Phone 다시 살펴보기 (상속 코드문제 해결기법)
- 차이(Diff)를 메서드로 추출 
  - 로직의 차이점을 추가적인 메서드로 추출

- 추상화가 핵심
- 의도를 드러내는 이름 사용


### 4) 차이에 의한 프로그래밍
- 중복 코드 제거: 코드를 재사용 단위로 분해, 재구성
- 코드 재사용: 중복코드 제거, 하나의 모듈로 모음
- *** 사실 위 두 용어는 동일한 행동을 가리키는 서로 다른 단어

### 결론
- 상속은 코드 재사용에 효율적인 방식이지만, 결합도를 높일 수 있는 위험이 존재한다.


